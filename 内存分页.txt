由于所有用户进程总的虚拟地址空间比可用的物理内存大很多，因此只有最常用的部分才与物理页帧关联。
这不是问题，因为大多数程序只占用实际可用内存的一小部分。
在将磁盘上的数据映射到进程的虚拟地址空间的时，内核必须提供数据结构，
以建立虚拟地址空间的区域和相关数据所在位置之间的关联。例如，在映射文本文件时，
映射的虚拟内存区必须关联到文件系统的硬盘上存储文件内容的区域。
因为文件数据在硬盘上的存储通常并不是连续的，而是分布到若干小的区域。
内核利用address_space数据结构，提供一组方法从后备存储器读取数据。例如，从文件系统读取。
因此address_space形成了一个辅助层，将映射的数据表示为连续的线性区域，提供给内存管理子系统。
按需分配和填充页称为按需调页法。它基于处理器和内核之间的交互，使用的各种数据结构

内存地址映射过程：
CPU将一个虚拟内存空间中的地址转换为物理地址，需要进行两步：
首先，将给定一个逻辑地址（其实是段内偏移量，这个一定要理解！！！），
CPU要利用其段式内存管理单元，先将为个逻辑地址转换成一个线程地址，
其次，再利用其页式内存管理单元，转换为最终物理地址。
这样做两次转换，的确是非常麻烦而且没有必要的，因为直接可以把线性地址抽像给进程。
之所以这样冗余，完全是为了兼容而已。
进程试图访问用户地址空间中的一个内存地址，利用上面的线性地址去查找页表，
确定对应的物理地址，但使用的页表无法确定物理地址（物理内存中没有关联页）
处理器接下来触发一个缺页异常，发送到内核。
内核会检查负责缺页区域的进程地址空间数据结构，找到适当的后备存储器，
或者确认该访问实际上是不正确的（未映射，未使用）
分配物理内存页，并从后备存储器读取所需数据填充。
借助于页表将物理内存页并入到用户进程的地址空间，应用程序恢复执行。
这些操作对用户进程是透明的。换句话说，
进程不会注意到页是实际在物理内存中，还是需要通过按需调页加载。

虚拟内存---映射--->物理内存
页表：操作系统维护着一张页表，用来映射(对应)虚拟页面和物理页面。

分块装入内存：
将数据分块装入内存，这一个个的块叫作页框
时间局部性：
如果程序中某条指令开始执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。
空间局部性：
指一旦程序访问量某个存储单元，则不久之后，其附近的存储单元也将被访问。
