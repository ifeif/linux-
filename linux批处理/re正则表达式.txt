正则表达式是通配符匹配的高级形式，它可以指定文本模式。我们借助这种模式来匹配文本进行输出。
使用正则表达式进行文本匹配的一个典型例子就是从一堆文本中解析出所有的E-mail地址。
E-mail地址通常采用name@host.root这种形式，
所以可以将其一般化为[a-z0-9]+@[a-z0-9]+.[a-z0-9]+。
符号+指明在它之前的字符类中的字符可以出现一次或多次。

正则表达式如何匹配任意字符？
shell用*匹配任意字符串，正则表达式用.*匹配任意字符串。

re	描 述				示 例
-----------------------------------------------------------------------------------------------------------------------------------------
^	行起始标记			^tux 匹配以tux起始的行，不能在^前面再跟上其他字符
$	行尾标记				tux$ 匹配以tux结尾的行，不能在$后面再跟上其他字符
. 	匹配任意一个字符			Hack. 匹配Hackl和Hacki，但是不能匹配Hackl2和Hackil，它只能匹配单个字符
[]	匹配包含在 [字符] 之中的任意一个字符	coo[kl] 匹配cook或cool 
[^]	匹配除 [^字符] 之外的任意一个字符	9[^01] 匹配92、93，但是不匹配91或90 
[-]	匹配 [] 中指定范围内的任意一个字符	[1-5] 匹配从1～5的任意一个数字
()	创建一个用于匹配的子串		ma(tri)?x 匹配max或maxtrix，当字符串没有用括号括起来时，则整个字符串都是一个匹配项
?	匹配之前的项1次或0次		colou?r 匹配color或colour，但是不能匹配colouur 
+	匹配之前的项1次或多次		Rollno-9+ 匹配Rollno-99、Rollno-9，但是不能匹配Rollno- 
*	匹配之前的项0次或多次		co*l 匹配cl、col、coool等
{n}	匹配之前的项n次			[0-9]{3} 匹配任意一个三位数， [0-9]{3} 可以扩展为[0-9][0-9][0-9] 
{n,}	之前的项至少需要匹配n次		[0-9]{2,} 匹配任意一个两位或更多位的数字
{n,m}	之前的项必须匹配n到m次之间		[0-9]{2,5} 匹配从两位数到五位数之间的任意一个数字
|	交替匹配，匹配 | 两边的任意一项	Oct (1st | 2nd) 匹配Oct 1st或Oct 2nd 
\	将上面介绍的特殊字符进行转义		a\.b匹配a.b，但不能匹配ajb。通过在 . 之间加上前缀 \ ，从而忽略了 . 的特殊意义
-----------------------------------------------------------------------------------------------------------------------------------------
正则表达式\特殊转义：
\d：匹配一个数字字符，等价于[0-9]
\D：匹配一个非数字字符。等价于[^0-9]
\w：匹配一个常用字符(这里的常用指的是变量命名)，等价于[0-9a-zA-Z_]
\W：匹配一个非常用字符，等价于[^0-9a-zA-Z_]
\s：匹配一个空白字符(空格、制表、换行)
\S：匹配一个非空白字符
示例：
匹配字符串中的string字符串：
string
匹配带有(包含)string的任何字符串：
(.*)string(.*)
匹配两个字符串A与B中间的字符串并包含A与B：
A.*?B
匹配两个字符串A与B中间的字符串并包含A但是不包含B：
A.*?(?=B) 
匹配两个字符串A与B中间的字符串且不包含A与B：
(?<=A).*?(?=B)

用圆括号会使圆括号内匹配成功的值缓存(保存)起来，此时可用?:放在括号内的第一个选项前(开头)来取消缓存。
要理解?:则需要理解捕获分组和非捕获分组的概念：
	()表示捕获分组，()会把每个分组里的匹配到的值保存起来，在shell中使用$n来查看(n是一个数字，表示第n个捕获组的内容)
	(?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配成功的值不会保存起来
?:是非捕获元之一，还有两个非捕获元是?=和?!，这两个还有更多的含义，
前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，
后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。
?:、?=、?<=、?!、?<!的区别：
(?:exp1)(?:exp2)：匹配到的exp1和exp2不会被保存起来。
exp1(?=exp2)：查找(匹配)exp2前面的exp1。
(?<=exp2)exp1：查找(匹配)exp2后面的exp1。
exp1(?!exp2)：查找(匹配)后面不是exp2 的exp1。
(?<!exp2)exp1：查找(匹配)前面不是exp2的exp1。

正则表达式在线练习工具：
https://regex101.com/
https://goregex.cn/
https://c.runoob.com/front-end/854/
参考资料：
https://www.runoob.com/regexp/regexp-tutorial.html
https://blog.csdn.net/weixin_43452467/article/details/113884408
https://zhuanlan.zhihu.com/p/27338649
https://www.jianshu.com/p/5d759797fdf0
https://blog.csdn.net/csm0912/article/details/81206848
https://blog.csdn.net/weixin_46927507/article/details/114029642
https://blog.csdn.net/lfcss/article/details/102777630